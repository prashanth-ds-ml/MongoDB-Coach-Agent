{
  "url": "https://www.mongodb.com/docs/manual/reference/bson-types/",
  "doc_type": "mongodb_docs_article",
  "method_name": null,
  "title": "BSON Types",
  "version": null,
  "breadcrumbs": [],
  "sections": [
    {
      "section_id": "binary-data",
      "heading": "Binary Data",
      "heading_level": 2,
      "content": "A BSON binary binData value is a byte array. A binData value\nhas a subtype that indicates how to interpret the binary data. The\nfollowing table shows the subtypes:\n0\nGeneric binary subtype\n1\nFunction data\n2\nBinary (old)\n3\nUUID (old)\n4\nUUID\n5\nMD5\n6\nEncrypted BSON value\n7\nCompressed time series data\nNew in version 5.2 .\n8\nSensitive data, such as a key or secret. MongoDB does not log\nliteral values for binary data with subtype 8. Instead, MongoDB\nlogs a placeholder value of ### .\n9\nVector data, which is densely packed arrays of numbers of the\nsame type.\n128\nCustom data",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "objectid",
      "heading": "ObjectId",
      "heading_level": 2,
      "content": "ObjectIds are small, likely unique, fast to generate, and ordered.\nObjectId values are 12 bytes in length, consisting of:\n- A 4-byte timestamp, representing the ObjectId's creation, measured in seconds since the\nUnix epoch.\n- A 5-byte random value generated once per client-side process. This random value is unique to the\nmachine and process. If the process restarts or the primary node of the process changes,\nthis value is re-generated.\n- A 3-byte incrementing counter per client-side process, initialized to a random value.\nThe counter resets when a process restarts.\nA 4-byte timestamp, representing the ObjectId's creation, measured in seconds since the\nUnix epoch.\nA 4-byte timestamp, representing the ObjectId's creation, measured in seconds since the\nUnix epoch.\nA 5-byte random value generated once per client-side process. This random value is unique to the\nmachine and process. If the process restarts or the primary node of the process changes,\nthis value is re-generated.\nA 5-byte random value generated once per client-side process. This random value is unique to the\nmachine and process. If the process restarts or the primary node of the process changes,\nthis value is re-generated.\nA 3-byte incrementing counter per client-side process, initialized to a random value.\nThe counter resets when a process restarts.\nA 3-byte incrementing counter per client-side process, initialized to a random value.\nThe counter resets when a process restarts.\nFor timestamp and counter values, the most significant bytes appear\nfirst in the byte sequence (big-endian). This is unlike other BSON\nvalues, where the least significant bytes appear first (little-endian).\nIf an integer value is used to create an ObjectId, the integer replaces\nthe timestamp.\nIn MongoDB, each document stored in a standard collection requires a unique _id field that acts as a primary key . If an inserted\ndocument omits the _id field, the MongoDB driver automatically\ngenerates an ObjectId for the _id field.\nThis also applies to documents inserted through update\noperations with upsert: true .\nMongoDB clients should add an _id field with a unique ObjectId.\nUsing ObjectIds for the _id field provides the following additional\nbenefits:\n- You can access ObjectId creation time in mongosh using the ObjectId.getTimestamp() method.\n- ObjectIds are approximately ordered by creation time, but are not\nperfectly ordered. Sorting a collection on an _id field\ncontaining ObjectId values is roughly equivalent to sorting by\ncreation time. Important While ObjectId values should increase over time, they are not\nnecessarily monotonic. This is because they: Only contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed\nordering, and Are generated by clients, which may have differing system clocks.\n- Only contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed\nordering, and\n- Are generated by clients, which may have differing system clocks.\nYou can access ObjectId creation time in mongosh using the ObjectId.getTimestamp() method.\nObjectIds are approximately ordered by creation time, but are not\nperfectly ordered. Sorting a collection on an _id field\ncontaining ObjectId values is roughly equivalent to sorting by\ncreation time. Important While ObjectId values should increase over time, they are not\nnecessarily monotonic. This is because they: Only contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed\nordering, and Are generated by clients, which may have differing system clocks.\nObjectIds are approximately ordered by creation time, but are not\nperfectly ordered. Sorting a collection on an _id field\ncontaining ObjectId values is roughly equivalent to sorting by\ncreation time.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "important",
      "heading": "Important",
      "heading_level": 2,
      "content": "While ObjectId values should increase over time, they are not\nnecessarily monotonic. This is because they:\n- Only contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed\nordering, and\n- Are generated by clients, which may have differing system clocks.\nOnly contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed\nordering, and\nOnly contain one second of temporal resolution, so ObjectId values created within the same second do not have a guaranteed\nordering, and\nAre generated by clients, which may have differing system clocks.\nUse the ObjectId() methods to set and retrieve ObjectId\nvalues.\nStarting in MongoDB 5.0, mongosh replaces the legacy mongo shell. The ObjectId() methods work differently in mongosh than\nin the legacy mongo shell. For more information on the legacy\nmethods, see Legacy mongo Shell .",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "string",
      "heading": "String",
      "heading_level": 2,
      "content": "BSON strings are UTF-8. In general, drivers for each programming\nlanguage convert from the language's string format to UTF-8 when\nserializing and deserializing BSON. This makes it possible to store\nmost international characters in BSON strings with ease. [ 1 ] In addition, MongoDB $regex queries support UTF-8 in the regex string.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "timestamps",
      "heading": "Timestamps",
      "heading_level": 2,
      "content": "BSON has a special timestamp type for internal MongoDB use and is not associated with the regular Date type. This internal timestamp type is a 64 bit value where:\n- the most significant 32 bits are a time_t value (seconds since\nthe Unix epoch)\n- the least significant 32 bits are an incrementing ordinal for\noperations within a given second.\nthe most significant 32 bits are a time_t value (seconds since\nthe Unix epoch)\nthe most significant 32 bits are a time_t value (seconds since\nthe Unix epoch)\nthe least significant 32 bits are an incrementing ordinal for\noperations within a given second.\nthe least significant 32 bits are an incrementing ordinal for\noperations within a given second.\nWhile the BSON format is little-endian, and therefore stores the least\nsignificant bits first, the mongod instance\nalways compares the time_t value before\nthe ordinal value on all platforms, regardless of\nendianness.\nIn replication, the oplog has a ts field. The values in\nthis field reflect the operation time, which uses a BSON timestamp\nvalue.\nWithin a single mongod instance, timestamp values in the oplog are always unique.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "The BSON timestamp type is for internal MongoDB use. For most\ncases, in application development, you will want to use the BSON\ndate type. See Date for more\ninformation.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "date",
      "heading": "Date",
      "heading_level": 2,
      "content": "BSON Date is a 64-bit integer that represents the number of\nmilliseconds since the Unix epoch (Jan 1, 1970). This results in a\nrepresentable date range of about 290 million years into the past and\nfuture.\nThe official BSON specification refers to the BSON Date type as the UTC datetime .\nBSON Date type is signed. [ 2 ] Negative values represent\ndates before 1970.\nTo construct a Date in mongosh , you can use the new Date() or ISODate() constructor.",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "construct-a-date-with-the-new-date()-constructor",
          "heading": "Construct a Date With the New Date() Constructor",
          "heading_level": 3,
          "content": "To construct a Date with the new Date() constructor, run the following\ncommand:\nThe mydate1 variable outputs a date and time wrapped as an ISODate:",
          "code_blocks": [
            "var mydate1 = new Date ( )",
            "mydate1",
            "ISODate ( \"2020-05-11T20:14:14.796Z\" )"
          ]
        },
        {
          "subsection_id": "construct-a-date-with-the-isodate()-constructor",
          "heading": "Construct a Date With the ISODate() Constructor",
          "heading_level": 3,
          "content": "To construct a Date using the ISODate() constructor, run the following\ncommand:\nThe mydate2 variable stores a date and time wrapped as an ISODate:",
          "code_blocks": [
            "var mydate2 = ISODate ( )",
            "mydate2",
            "ISODate ( \"2020-05-11T20:14:14.796Z\" )"
          ]
        },
        {
          "subsection_id": "convert-a-date-to-a-string",
          "heading": "Convert a Date to a String",
          "heading_level": 3,
          "content": "To print the Date in a string format, use the toString() method:",
          "code_blocks": [
            "mydate1. toString ( )",
            "Mon May 11 2020 13 : 14 : 14 GMT - 0700 ( Pacific Daylight Time )"
          ]
        },
        {
          "subsection_id": "return-the-month-portion-of-a-date",
          "heading": "Return the Month Portion of a Date",
          "heading_level": 3,
          "content": "You can also return the month portion of the Date value. Months are\nzero-indexed, so that January is month 0 .",
          "code_blocks": [
            "mydate1. getMonth ( )",
            "4"
          ]
        }
      ]
    },
    {
      "section_id": "decimal128-bson-data-type",
      "heading": "decimal128 BSON Data Type",
      "heading_level": 2,
      "content": "decimal128 is a 128-bit decimal representation for storing very\nlarge or very precise numbers, whenever rounding decimals is important.\nIt was created in August 2009 as part of the IEEE 754-2008 revision of floating points. When you need high precision when\nworking with BSON data types, you should use decimal128 .\ndecimal128 supports 34 decimal digits of precision, or significand along with\nan exponent range of -6143 to +6144. The significand is not normalized\nin the decimal128 standard, allowing for multiple possible representations: 10 x 10^-1 = 1 x 10^0 = .1 x 10^1 = .01 x 10^2 , etc. Having the\nability to store maximum and minimum values in the order of 10^6144 and 10^-6143 , respectively, allows for a lot of precision.",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "use-decimal128-with-the-decimal128()-constructor",
          "heading": "Use decimal128 With the Decimal128() Constructor",
          "heading_level": 3,
          "content": "In MongoDB, you can store data in decimal128 format using the Decimal128() constructor. If you pass in the decimal value\nas a string, MongoDB stores the value in the database as follows:\nYou can also pass in the decimal value as a double :\nYou should also consider the usage and support your programming\nlanguage has for decimal128 . The following languages donâ€™t\nnatively support this feature and require a plugin\nor additional package to get the functionality:\n- Python: The decimal.Decimal module can be used for floating-point arithmetic.\n- Java: The Java BigDecimal class provides support for decimal128 numbers.\n- Node.js: There are several packages that provide support,\nsuch as js-big-decimal or node.js bigdecimal available on npm .\nPython: The decimal.Decimal module can be used for floating-point arithmetic.\nJava: The Java BigDecimal class provides support for decimal128 numbers.\nNode.js: There are several packages that provide support,\nsuch as js-big-decimal or node.js bigdecimal available on npm .\nNode.js: There are several packages that provide support,\nsuch as js-big-decimal or node.js bigdecimal available on npm .",
          "code_blocks": [
            "Decimal128 ( \"9823.1297\" )",
            "Decimal128 . fromStringWithRounding ( \"1234.99999999999\" )"
          ]
        },
        {
          "subsection_id": "use-cases",
          "heading": "Use Cases",
          "heading_level": 3,
          "content": "When you perfom mathematical calculations programmatically, you can sometimes\nreceive unexpected results. The following example in Node.js yields incorrect results:\nSimilarly, the following example in Java produces incorrect output:\nThe same computations in Python, Ruby, Rust, and other languages\nproduce the same results. This happens because binary floating-point\nnumbers do not represent base 10 values well.\nFor example, the 0.1 used in the above examples is represented\nin binary as 0.0001100110011001101 . Most of the time, this\ndoes not cause any significant issues. However, in applications\nsuch as finance or banking where precision is important,\nuse decimal128 as your data type.\nLegacy mongo Shell\nComparison and Sort Order\n- Binary Data\n- ObjectId\n- String\n- Timestamps\n- Date\n- decimal128 BSON Data Type\nBinary Data\nObjectId\nString\nTimestamps\nDate\ndecimal128 BSON Data Type\n- Binary Data\n- ObjectId\n- String\n- Timestamps\n- Date\n- decimal128 BSON Data Type\nBinary Data\nObjectId\nString\nTimestamps\nDate\ndecimal128 BSON Data Type",
          "code_blocks": [
            "> 0.1 0.1 > 0.2 0.2 > 0.1 * 0.2 0.020000000000000004 > 0.1 + 0.1 0.010000000000000002",
            "1 class Main { 2 public static void main (String[] args) { 3 System.out.println( \"0.1 * 0.2:\" ); 4 System.out.println( 0.1 * 0.2 ); 5 } 6 }",
            "1 0.1 * 0.2 : 2 0.020000000000000004"
          ]
        }
      ]
    }
  ],
  "fetched_at": "2025-12-09T03:46:08.364425",
  "exam_code": "associate_developer_python",
  "domain_id": 1,
  "domain_name": "MongoDB Overview and the Document Model",
  "seed_id": "bson-types",
  "source_type": "manual",
  "file_stub": "d1_bson-types"
}