{
  "url": "https://www.mongodb.com/docs/manual/reference/method/db.collection.findAndModify/",
  "doc_type": "mongodb_docs_method",
  "method_name": "db.collection.findAndModify",
  "title": "db.collection.findAndModify() (mongosh method)",
  "version": null,
  "breadcrumbs": [],
  "sections": [
    {
      "section_id": "important",
      "heading": "Important",
      "heading_level": 2,
      "content": "",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "deprecated-mongosh-method",
          "heading": "Deprecated mongosh Method",
          "heading_level": 3,
          "content": "Use findOneAndUpdate() , findOneAndDelete() , or findOneAndReplace() instead.",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "definition",
      "heading": "Definition",
      "heading_level": 2,
      "content": "Updates and returns a single document. By default, the returned\ndocument does not include the modifications made on the update. To\nreturn the document with the modifications made on the update, use\nthe new option.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "compatibility",
      "heading": "Compatibility",
      "heading_level": 2,
      "content": "This method is available in deployments hosted in the following environments:\n- MongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud\nMongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud\nMongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "This command is supported in all MongoDB Atlas clusters.\nFor information on Atlas support for all commands, see Unsupported Commands .\n- MongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB\n- MongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB\nMongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB\nMongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB\nMongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB\nMongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "syntax",
      "heading": "Syntax",
      "heading_level": 2,
      "content": "Changed in version 5.0 .\nThe findAndModify() method has the following\nform:",
      "code_blocks": [
        "db.collection.findAndModify({ query: <document>, sort: <document>, remove: <boolean>, update: <document or aggregation pipeline>, new: <boolean>, fields: <document>, upsert: <boolean>, bypassDocumentValidation: <boolean>, writeConcern: <document>, maxTimeMS: <integer>, collation: <document>, arrayFilters: [ <filterdocument1>, ... ], let: <document> // Added in MongoDB 5.0 });"
      ],
      "subsections": [
        {
          "subsection_id": "parameters",
          "heading": "Parameters",
          "heading_level": 3,
          "content": "The db.collection.findAndModify() method takes a document\nparameter with the following embedded document fields:\nquery\ndocument\nOptional. The selection criteria for the modification. The query field\nemploys the same query selectors as used in\nthe db.collection.find() method. Although the query may\nmatch multiple documents, db.collection.findAndModify() will only select one document to modify .\nIf unspecified, defaults to an empty document.\nIf the query argument is not a document, the operation errors.\nsort\ndocument\nOptional. Determines which document the operation updates if the query\nselects multiple documents. db.collection.findAndModify() updates\nthe first document in the sort order specified by this argument.\nIf the sort argument is not a document, the operation errors.\nMongoDB does not store documents in a collection in a particular order.\nWhen sorting on a field which contains duplicate values, documents\ncontaining those values may be returned in any order.\nThe $sort operation is not a \"stable sort,\" which means that documents\nwith equivalent sort keys are not guaranteed to remain in the same relative\norder in the output as they were in the input.\nIf the field specified in the sort criteria does not exist in two documents, then\nthe value on which they are sorted is the same. The two documents may be returned\nin any order.\nIf consistent sort order is desired, include at least one field in your\nsort that contains unique values. The easiest way to guarantee this is\nto include the _id field in your sort query.\nSee Sort Consistency for more information.\nremove\nboolean\nMust specify either the remove or the update field. Removes\nthe document specified in the query field. Set this to true to remove the selected document . The default is false .\nupdate\ndocument or array\nMust specify either the remove or the update field. Performs\nan update of the selected document.\n- If passed a document with update operator expressions , db.collection.findAndModify() performs the specified\nmodification.\n- If passed a replacement document { <field1>: <value1>, ...} ,\nthe db.collection.findAndModify() performs a replacement.\n- If passed an aggregation pipeline [ <stage1>, <stage2>, ... ] , db.collection.findAndModify() updates the document per\nthe pipeline. The pipeline can consist of the following stages: $addFields and its alias $set $project and its alias $unset $replaceRoot and its alias $replaceWith\n- $addFields and its alias $set\n- $project and its alias $unset\n- $replaceRoot and its alias $replaceWith\nIf passed a document with update operator expressions , db.collection.findAndModify() performs the specified\nmodification.\nIf passed a document with update operator expressions , db.collection.findAndModify() performs the specified\nmodification.\nIf passed a replacement document { <field1>: <value1>, ...} ,\nthe db.collection.findAndModify() performs a replacement.\nIf passed a replacement document { <field1>: <value1>, ...} ,\nthe db.collection.findAndModify() performs a replacement.\nIf passed an aggregation pipeline [ <stage1>, <stage2>, ... ] , db.collection.findAndModify() updates the document per\nthe pipeline. The pipeline can consist of the following stages: $addFields and its alias $set $project and its alias $unset $replaceRoot and its alias $replaceWith\nIf passed an aggregation pipeline [ <stage1>, <stage2>, ... ] , db.collection.findAndModify() updates the document per\nthe pipeline. The pipeline can consist of the following stages:\n- $addFields and its alias $set\n- $project and its alias $unset\n- $replaceRoot and its alias $replaceWith\n$addFields and its alias $set\n$project and its alias $unset\n$replaceRoot and its alias $replaceWith\nnew\nboolean\nOptional. When true , returns the updated document rather than the original.\nThe default is false .\nfields\ndocument\nOptional. A subset of fields to return. The fields document specifies\nan inclusion of a field with 1 , as in: fields: { <field1>: 1,\n<field2>: 1, ... } .\nIf the fields argument is not a document, the operation errors.\nFor more information on projection, see fields Projection .\nupsert\nboolean\nOptional. Used in conjunction with the update field.\nWhen true , findAndModify() either:\n- Creates a new document if no documents match the query .\nFor more details see upsert behavior .\n- Updates a single document that matches the query .\nCreates a new document if no documents match the query .\nFor more details see upsert behavior .\nCreates a new document if no documents match the query .\nFor more details see upsert behavior .\nUpdates a single document that matches the query .\nTo avoid multiple upserts , ensure that the query field(s) are uniquely indexed . See Upsert with Unique Index for an example.\nDefaults to false , which does not insert a new document when no\nmatch is found.\nbypassDocumentValidation\nboolean\nOptional. Enables db.collection.findAndModify() to bypass schema validation\nduring the operation. This lets you update documents that do not\nmeet the validation requirements.\nwriteConcern\ndocument\nOptional. A document expressing the write concern .\nOmit to use the default write concern.\nDo not explicitly set the write concern for the operation if run in\na transaction. To use write concern with transactions, see Transactions and Write Concern .\nmaxTimeMS\nnon-negative integer\nOptional.\nSpecifies a time limit in milliseconds.\nIf you do not specify a value for maxTimeMS , operations will not time out.\nA value of 0 explicitly specifies the default unbounded behavior.\nMongoDB terminates operations that exceed their allotted time limit\nusing the same mechanism as db.killOp() . MongoDB only\nterminates an operation at one of its designated interrupt\npoints .\ncollation\ndocument\nOptional.\nSpecifies the collation to use for the operation.\nCollation allows users to specify\nlanguage-specific rules for string comparison, such as rules for\nlettercase and accent marks.\nThe collation option has the following syntax:\nWhen specifying collation, the locale field is mandatory; all\nother collation fields are optional. For descriptions of the fields,\nsee Collation Document .\nIf the collation is unspecified but the collection has a\ndefault collation (see db.createCollection() ), the\noperation uses the collation specified for the collection.\nIf no collation is specified for the collection or for the\noperations, MongoDB uses the simple binary comparison used in prior\nversions for string comparisons.\nYou cannot specify multiple collations for an operation. For\nexample, you cannot specify different collations per field, or if\nperforming a find with a sort, you cannot use one collation for the\nfind and another for the sort.\narrayFilters\narray\nOptional. An array of filter documents that determine which array elements to\nmodify for an update operation on an array field.\nIn the update document, use the $[<identifier>] filtered\npositional operator to define an identifier, which you then reference\nin the array filter documents. You cannot have an array filter\ndocument for an identifier if the identifier is not included in the\nupdate document.\nThe <identifier> must begin with a lowercase letter and\ncontain only alphanumeric characters.\nYou can include the same identifier multiple times in the update\ndocument; however, for each distinct identifier ( $[identifier] )\nin the update document, you must specify exactly one corresponding array filter document. That is, you cannot specify\nmultiple array filter documents for the same identifier. For\nexample, if the update statement includes the identifier x (possibly multiple times), you cannot specify the following for arrayFilters that includes 2 separate filter documents for x :\nHowever, you can specify compound conditions on the same identifier\nin a single filter document, such as in the following examples:\nFor examples, see Specify arrayFilters for an Array Update Operations .\narrayFilters is not available for updates that use an\naggregation pipeline.\nlet\ndocument\nOptional.\nSpecifies a document with a list of variables. This allows you to\nimprove command readability by separating the variables from the query\ntext.\nThe document syntax is:\nThe variable is set to the value returned by the expression, and cannot\nbe changed afterwards.\nTo access the value of a variable in the command, use the double\ndollar sign prefix ( $$ ) together with your variable name in the form $$<variable_name> . For example: $$targetTotal .\nTo use a variable to filter results, you must access the variable\nwithin the $expr operator.\nFor a complete example using let and variables,\nsee Use Variables in let .\nNew in version 5.0 .",
          "code_blocks": [
            "collation: { locale: <string>, caseLevel: <boolean>, caseFirst: <string>, strength: <int>, numericOrdering: <boolean>, alternate: <string>, maxVariable: <string>, backwards: <boolean> }",
            "// INVALID [ { \"x.a\" : { $gt : 85 } } , { \"x.b\" : { $gt : 80 } } ]",
            "// Example 1 [ { $or : [ { \"x.a\" : { $gt : 85 }} , { \"x.b\" : { $gt : 80 }}] } ] // Example 2 [ { $and : [ { \"x.a\" : { $gt : 85 }} , { \"x.b\" : { $gt : 80 }}] } ] // Example 3 [ { \"x.a\" : { $gt : 85 } , \"x.b\" : { $gt : 80 } } ]",
            "{ < variable_name_1 > : < expression_1 > , ... , < variable_name_n > : < expression_n > }"
          ]
        }
      ]
    },
    {
      "section_id": "return-data",
      "heading": "Return Data",
      "heading_level": 2,
      "content": "For remove operations, if the query matches a document, findAndModify() returns the removed document.\nIf the query does not match a document to remove, findAndModify() returns null .\nFor update operations, findAndModify() returns\none of the following:\n- If the new parameter is not set or is false : the pre-modification document if the query matches a document; otherwise, null .\n- the pre-modification document if the query matches a document;\n- otherwise, null .\n- If new is true : the updated document if the query returns a match; the inserted document if upsert: true and no document matches the query; otherwise, null .\n- the updated document if the query returns a match;\n- the inserted document if upsert: true and no document matches the query;\n- otherwise, null .\nIf the new parameter is not set or is false : the pre-modification document if the query matches a document; otherwise, null .\nIf the new parameter is not set or is false :\n- the pre-modification document if the query matches a document;\n- otherwise, null .\nthe pre-modification document if the query matches a document;\notherwise, null .\nIf new is true : the updated document if the query returns a match; the inserted document if upsert: true and no document matches the query; otherwise, null .\nIf new is true :\n- the updated document if the query returns a match;\n- the inserted document if upsert: true and no document matches the query;\n- otherwise, null .\nthe updated document if the query returns a match;\nthe inserted document if upsert: true and no document matches the query;\notherwise, null .",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "behavior",
      "heading": "Behavior",
      "heading_level": 2,
      "content": "",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "performance",
          "heading": "Performance",
          "heading_level": 3,
          "content": "Retryable writes require the findAndModify() method to copy the entire document into\na special side collection for each node in a replica set before it performs\nthe update. This can make findAndModify() an expensive operation when dealing with\nlarge documents or large replica sets.\nNew in version 8.0 : To update the first document in a user-defined ordering with\nbetter performance, use the db.collection.updateOne() method with the sort option.",
          "code_blocks": []
        },
        {
          "subsection_id": "fields-projection",
          "heading": "fields Projection",
          "heading_level": 3,
          "content": "",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "important",
      "heading": "Important",
      "heading_level": 2,
      "content": "",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "language-consistency",
          "heading": "Language Consistency",
          "heading_level": 3,
          "content": "As part of making find() and findAndModify() projection consistent with\naggregation's $project stage,\n- The find() and findAndModify() projection can accept aggregation expressions and syntax .\n- MongoDB enforces additional restrictions with regards to\nprojections. See Projection Restrictions for details.\nThe find() and findAndModify() projection can accept aggregation expressions and syntax .\nMongoDB enforces additional restrictions with regards to\nprojections. See Projection Restrictions for details.\nMongoDB enforces additional restrictions with regards to\nprojections. See Projection Restrictions for details.\nThe fields option takes a document in the following form:\n<field>: <1 or true>\nSpecifies the inclusion of a field. If you specify a non-zero\ninteger for the projection value, the operation treats the\nvalue as true .\n<field>: <0 or false>\nSpecifies the exclusion of a field.\n\"<field>.$\": <1 or true>\nUses the $ array projection operator to return\nthe first element that matches the query condition on the\narray field. If you specify a non-zero integer for the\nprojection value, the operation treats the value as true .\nNot available for views .\n<field>: <array projection>\nUses the array projection operators ( $elemMatch , $slice ) to specify the array elements to\ninclude.\nNot available for views .\n<field>: <aggregation expression>\nSpecifies the value of the projected field.\nWith the use of aggregation\nexpressions and syntax , including the\nuse of literals and aggregation variables, you can project new\nfields or project existing fields with new values.\n- If you specify a non-numeric, non-boolean literal (such as a\nliteral string or an array or an operator expression) for\nthe projection value, the field is projected with the new\nvalue, for example: { field: [ 1, 2, 3, \"$someExistingField\" ] } { field: \"New String Value\" } { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\n- { field: [ 1, 2, 3, \"$someExistingField\" ] }\n- { field: \"New String Value\" }\n- { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\n- To project a literal value for a field, use the $literal aggregation expression, for example: { field: { $literal: 5 } } { field: { $literal: true } } { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\n- { field: { $literal: 5 } }\n- { field: { $literal: true } }\n- { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\nIf you specify a non-numeric, non-boolean literal (such as a\nliteral string or an array or an operator expression) for\nthe projection value, the field is projected with the new\nvalue, for example: { field: [ 1, 2, 3, \"$someExistingField\" ] } { field: \"New String Value\" } { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\nIf you specify a non-numeric, non-boolean literal (such as a\nliteral string or an array or an operator expression) for\nthe projection value, the field is projected with the new\nvalue, for example:\n- { field: [ 1, 2, 3, \"$someExistingField\" ] }\n- { field: \"New String Value\" }\n- { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\n{ field: [ 1, 2, 3, \"$someExistingField\" ] }\n{ field: \"New String Value\" }\n{ field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\nTo project a literal value for a field, use the $literal aggregation expression, for example: { field: { $literal: 5 } } { field: { $literal: true } } { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\nTo project a literal value for a field, use the $literal aggregation expression, for example:\n- { field: { $literal: 5 } }\n- { field: { $literal: true } }\n- { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\n{ field: { $literal: 5 } }\n{ field: { $literal: true } }\n{ field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\nFor fields in an embedded documents, you can specify the field using\neither:\n- dot notation , for example \"field.nestedfield\": <value>\n- nested form, for example { field: { nestedfield: <value> } }\ndot notation , for example \"field.nestedfield\": <value>\nnested form, for example { field: { nestedfield: <value> } }\nThe _id field is included in the returned documents by default unless\nyou explicitly specify _id: 0 in the projection to suppress the field.\nA projection cannot contain both include and exclude\nspecifications, with the exception of the _id field:\n- In projections that explicitly include fields, the _id field is\nthe only field that you can explicitly exclude .\n- In projections that explicitly excludes fields, the _id field\nis the only field that you can explicitly include ; however, the _id field is included by default.\nIn projections that explicitly include fields, the _id field is\nthe only field that you can explicitly exclude .\nIn projections that explicitly include fields, the _id field is\nthe only field that you can explicitly exclude .\nIn projections that explicitly excludes fields, the _id field\nis the only field that you can explicitly include ; however, the _id field is included by default.\nIn projections that explicitly excludes fields, the _id field\nis the only field that you can explicitly include ; however, the _id field is included by default.\nFor more information on projection, see also:\n- Project Fields to Return from Query\nProject Fields to Return from Query",
          "code_blocks": [
            "{ field1 : < value > , field2 : < value > ... }"
          ]
        },
        {
          "subsection_id": "upsert-with-unique-index",
          "heading": "Upsert with Unique Index",
          "heading_level": 3,
          "content": "Upserts can create duplicate documents, unless there is a unique index to prevent duplicates.\nConsider an example where no document with the name Andy exists\nand multiple clients issue the following command at roughly the same\ntime:\nIf all findOneAndUpdate() operations finish the query phase before any\nclient successfully inserts data, and there is no unique index on\nthe name field, each findOneAndUpdate() operation may result in an\ninsert, creating multiple documents with name: Andy .\nA unique index on the name field ensures that only one document\nis created. With a unique index in place, the multiple findOneAndUpdate() operations now exhibit the following behavior:\n- Exactly one findOneAndUpdate() operation will successfully insert a new\ndocument.\n- Other findOneAndUpdate() operations either update the newly-inserted\ndocument or fail due to a unique key collision. In order for other findOneAndUpdate() operations to update the\nnewly-inserted document, all of the following conditions must\nbe met: The target collection has a unique index that would cause a\nduplicate key error. The update operation is not updateMany or multi is false . The update match condition is either: A single equality predicate. For example { \"fieldA\" : \"valueA\" } A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" } The fields in the equality predicate match the fields in the\nunique index key pattern. The update operation does not modify any fields in the\nunique index key pattern.\n- The target collection has a unique index that would cause a\nduplicate key error.\n- The update operation is not updateMany or multi is false .\n- The update match condition is either: A single equality predicate. For example { \"fieldA\" : \"valueA\" } A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\n- A single equality predicate. For example { \"fieldA\" : \"valueA\" }\n- A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\n- The fields in the equality predicate match the fields in the\nunique index key pattern.\n- The update operation does not modify any fields in the\nunique index key pattern.\nExactly one findOneAndUpdate() operation will successfully insert a new\ndocument.\nExactly one findOneAndUpdate() operation will successfully insert a new\ndocument.\nOther findOneAndUpdate() operations either update the newly-inserted\ndocument or fail due to a unique key collision. In order for other findOneAndUpdate() operations to update the\nnewly-inserted document, all of the following conditions must\nbe met: The target collection has a unique index that would cause a\nduplicate key error. The update operation is not updateMany or multi is false . The update match condition is either: A single equality predicate. For example { \"fieldA\" : \"valueA\" } A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" } The fields in the equality predicate match the fields in the\nunique index key pattern. The update operation does not modify any fields in the\nunique index key pattern.\nOther findOneAndUpdate() operations either update the newly-inserted\ndocument or fail due to a unique key collision.\nIn order for other findOneAndUpdate() operations to update the\nnewly-inserted document, all of the following conditions must\nbe met:\n- The target collection has a unique index that would cause a\nduplicate key error.\n- The update operation is not updateMany or multi is false .\n- The update match condition is either: A single equality predicate. For example { \"fieldA\" : \"valueA\" } A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\n- A single equality predicate. For example { \"fieldA\" : \"valueA\" }\n- A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\n- The fields in the equality predicate match the fields in the\nunique index key pattern.\n- The update operation does not modify any fields in the\nunique index key pattern.\nThe target collection has a unique index that would cause a\nduplicate key error.\nThe target collection has a unique index that would cause a\nduplicate key error.\nThe update operation is not updateMany or multi is false .\nThe update match condition is either: A single equality predicate. For example { \"fieldA\" : \"valueA\" } A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\nThe update match condition is either:\n- A single equality predicate. For example { \"fieldA\" : \"valueA\" }\n- A logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\nA single equality predicate. For example { \"fieldA\" : \"valueA\" }\nA logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\nA logical AND of equality predicates. For example { \"fieldA\" :\n\"valueA\", \"fieldB\" : \"valueB\" }\nThe fields in the equality predicate match the fields in the\nunique index key pattern.\nThe fields in the equality predicate match the fields in the\nunique index key pattern.\nThe update operation does not modify any fields in the\nunique index key pattern.\nThe update operation does not modify any fields in the\nunique index key pattern.\nThe following table shows examples of upsert operations that,\nwhen a key collision occurs, either result in an update or fail.\nThe score field of the matched document is incremented by\n1.\nThe operation fails because it modifies the field in the\nunique index key pattern ( name ).\nThe operation fails because the equality predicate fields\n( name , email ) do not match the index key field\n( name ).",
          "code_blocks": [
            "db. people . findAndModify ( { query : { name : \"Andy\" } , update : { $inc : { score : 1 } } , upsert : true } )",
            "{ name : 1 }",
            "db. people . updateOne ( { name : \"Andy\" } , { $inc : { score : 1 } } , { upsert : true } )",
            "{ name : 1 }",
            "db. people . updateOne ( { name : { $ne : \"Joe\" } } , { $set : { name : \"Andy\" } } , { upsert : true } )",
            "{ name : 1 }",
            "db. people . updateOne ( { name : \"Andy\" , email : \"andy@xyz.com\" } , { $set : { active : false } } , { upsert : true } )"
          ]
        },
        {
          "subsection_id": "sharded-collections",
          "heading": "Sharded Collections",
          "heading_level": 3,
          "content": "To use findAndModify on a sharded collection:\n- If you only target one shard, you can use a partial shard key in the query field or,\n- You can provide an equality condition on a full shard key in the query field.\n- Starting in version 7.1, you do not need to provide the shard key or _id field in the query specification.\nIf you only target one shard, you can use a partial shard key in the query field or,\nYou can provide an equality condition on a full shard key in the query field.\nStarting in version 7.1, you do not need to provide the shard key or _id field in the query specification.\nDocuments in a sharded collection can be missing the shard key fields . To target a\ndocument that is missing the shard key, you can use the null equality match in conjunction with another filter condition\n(such as on the _id field). For example:\nYou can update a document's shard key value unless the shard key field is the\nimmutable _id field.",
          "code_blocks": [
            "{ _id : < value > , < shardkeyfield > : null } // _id of the document missing shard key"
          ]
        }
      ]
    },
    {
      "section_id": "warning",
      "heading": "Warning",
      "heading_level": 2,
      "content": "Documents in sharded collections can be missing the shard key fields.\nTake precaution to avoid accidentally removing the shard key when changing\na document's shard key value.\nTo update the existing shard key value with db.collection.findAndModify() :\n- You must run on a mongos . Do not issue the operation directly on the shard.\n- You must run either in a transaction or as a retryable write .\n- You must include an equality filter on the full shard key.\nYou must run on a mongos . Do not issue the operation directly on the shard.\nYou must run either in a transaction or as a retryable write .\nYou must include an equality filter on the full shard key.\nDocuments in a sharded collection can be missing the shard key fields . To use db.collection.findAndModify() to set the document's missing shard key:\n- You must run on a mongos . Do not issue the operation directly on the shard.\n- You must run either in a transaction or as a retryable write if the new shard key value is not null .\n- You must include an equality filter on the full shard key.\nYou must run on a mongos . Do not issue the operation directly on the shard.\nYou must run either in a transaction or as a retryable write if the new shard key value is not null .\nYou must include an equality filter on the full shard key.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "tip",
      "heading": "Tip",
      "heading_level": 2,
      "content": "Since a missing key value is returned as part of a null equality\nmatch, to avoid updating a null-valued key, include additional\nquery conditions (such as on the _id field) as appropriate.\nSee also:\n- Missing Shard Key Fields\nMissing Shard Key Fields",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "schema-validation",
          "heading": "Schema Validation",
          "heading_level": 3,
          "content": "The db.collection.findAndModify() method adds support for the bypassDocumentValidation option, which lets you bypass schema validation when\ninserting or updating documents in a collection with validation\nrules.",
          "code_blocks": []
        },
        {
          "subsection_id": "comparisons-with-the-update-method",
          "heading": "Comparisons with the update Method",
          "heading_level": 3,
          "content": "When updating a document, db.collection.findAndModify() and the updateOne() method operate differently:\n- If multiple documents match the update criteria, for db.collection.findAndModify() , you can specify a sort to provide some\nmeasure of control on which document to update. updateOne() updates the first document that\nmatches.\n- By default, db.collection.findAndModify() returns the pre-modified version of the document . To\nobtain the updated document, use the new option. The updateOne() method returns a WriteResult() object that contains the status of the operation. To return the updated document, use the find() method. However, other updates may have modified the document between\nyour update and the document retrieval. Also, if the update modified\nonly a single document but multiple documents matched, you will need to\nuse additional logic to identify the updated document.\nIf multiple documents match the update criteria, for db.collection.findAndModify() , you can specify a sort to provide some\nmeasure of control on which document to update. updateOne() updates the first document that\nmatches.\nIf multiple documents match the update criteria, for db.collection.findAndModify() , you can specify a sort to provide some\nmeasure of control on which document to update.\nupdateOne() updates the first document that\nmatches.\nBy default, db.collection.findAndModify() returns the pre-modified version of the document . To\nobtain the updated document, use the new option. The updateOne() method returns a WriteResult() object that contains the status of the operation. To return the updated document, use the find() method. However, other updates may have modified the document between\nyour update and the document retrieval. Also, if the update modified\nonly a single document but multiple documents matched, you will need to\nuse additional logic to identify the updated document.\nBy default, db.collection.findAndModify() returns the pre-modified version of the document . To\nobtain the updated document, use the new option.\nThe updateOne() method returns a WriteResult() object that contains the status of the operation.\nTo return the updated document, use the find() method. However, other updates may have modified the document between\nyour update and the document retrieval. Also, if the update modified\nonly a single document but multiple documents matched, you will need to\nuse additional logic to identify the updated document.\nWhen modifying a single document, both db.collection.findAndModify() and the updateOne() method atomically update the\ndocument. See Atomicity and Transactions for more\ndetails about interactions and order of operations of these methods.",
          "code_blocks": []
        },
        {
          "subsection_id": "transactions",
          "heading": "Transactions",
          "heading_level": 3,
          "content": "db.collection.findAndModify() can be used inside distributed transactions .",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "important",
      "heading": "Important",
      "heading_level": 2,
      "content": "In most cases, a distributed transaction incurs a greater\nperformance cost over single document writes, and the\navailability of distributed transactions should not be a\nreplacement for effective schema design. For many scenarios, the denormalized data model (embedded documents and arrays) will continue to be optimal for your\ndata and use cases. That is, for many scenarios, modeling your data\nappropriately will minimize the need for distributed\ntransactions.\nFor additional transactions usage considerations\n(such as runtime limit and oplog size limit), see also Production Considerations .\nYou can create collections and indexes inside a distributed\ntransaction if the\ntransaction is not a cross-shard write transaction.\ndb.collection.findAndModify() with upsert: true can be run on an existing\ncollection or a non-existing collection. If run on a non-existing\ncollection, the operation creates the collection.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "tip",
      "heading": "Tip",
      "heading_level": 2,
      "content": "Create Collections and Indexes in a Transaction\nDo not explicitly set the write concern for the operation if run in\na transaction. To use write concern with transactions, see Transactions and Write Concern .",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "oplog-entries",
          "heading": "Oplog Entries",
          "heading_level": 3,
          "content": "If a db.collection.findAndModify() operation successfully finds and\nmodifies a document, the operation adds an entry on the oplog (operations log). If the operation fails or does not find a document to\nmodify, the operation does not add an entry on the oplog.",
          "code_blocks": []
        },
        {
          "subsection_id": "write-concern-errors",
          "heading": "Write Concern Errors",
          "heading_level": 3,
          "content": "In MongoDB versions earlier than 6.0, if the findAndModify command\nis run on a sharded cluster, mongos discards the writeConcernError document if the shard response contains\nan error. In MongoDB 6.0 and later, mongos returns writeConcernError .",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "examples",
      "heading": "Examples",
      "heading_level": 2,
      "content": "",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "update-and-return",
          "heading": "Update and Return",
          "heading_level": 3,
          "content": "The following method updates and returns an existing document in the\npeople collection where the document matches the query criteria:\nThis method performs the following actions:\n- The query finds a document in the people collection\nwhere the name field has the value Tom , the state field has the value active and the rating field has a\nvalue greater than 10.\n- The sort orders the results of the query in ascending order.\nIf multiple documents meet the query condition, the method\nwill select for modification the first document as ordered by\nthis sort .\n- The update increments the value of the score field by 1.\n- The method returns the original (i.e. pre-modification) document\nselected for this update: { \"_id\" : ObjectId ( \"50f1e2c99beb36a0f45c6453\" ) , \"name\" : \"Tom\" , \"state\" : \"active\" , \"rating\" : 100 , \"score\" : 5 } To return the updated document, add the new:true option to\nthe method. If no document matched the query condition, the method\nreturns null .\nThe query finds a document in the people collection\nwhere the name field has the value Tom , the state field has the value active and the rating field has a\nvalue greater than 10.\nThe query finds a document in the people collection\nwhere the name field has the value Tom , the state field has the value active and the rating field has a\nvalue greater than 10.\nThe sort orders the results of the query in ascending order.\nIf multiple documents meet the query condition, the method\nwill select for modification the first document as ordered by\nthis sort .\nThe sort orders the results of the query in ascending order.\nIf multiple documents meet the query condition, the method\nwill select for modification the first document as ordered by\nthis sort .\nThe update increments the value of the score field by 1.\nThe method returns the original (i.e. pre-modification) document\nselected for this update: { \"_id\" : ObjectId ( \"50f1e2c99beb36a0f45c6453\" ) , \"name\" : \"Tom\" , \"state\" : \"active\" , \"rating\" : 100 , \"score\" : 5 } To return the updated document, add the new:true option to\nthe method. If no document matched the query condition, the method\nreturns null .\nThe method returns the original (i.e. pre-modification) document\nselected for this update:\nTo return the updated document, add the new:true option to\nthe method.\nIf no document matched the query condition, the method\nreturns null .",
          "code_blocks": [
            "db. people . findAndModify ( { query : { name : \"Tom\" , state : \"active\" , rating : { $gt : 10 } } , sort : { rating : 1 } , update : { $inc : { score : 1 } } })",
            "{ \"_id\" : ObjectId ( \"50f1e2c99beb36a0f45c6453\" ) , \"name\" : \"Tom\" , \"state\" : \"active\" , \"rating\" : 100 , \"score\" : 5 }"
          ]
        },
        {
          "subsection_id": "upsert",
          "heading": "Upsert",
          "heading_level": 3,
          "content": "The following method includes the upsert: true option for the update operation to either update a matching document or, if no\nmatching document exists, create a new document:\nIf the method finds a matching document, the method performs an update.\nIf the method does not find a matching document, the method creates\na new document. Because the method included the sort option, it\nreturns an empty document { } as the original (pre-modification)\ndocument:\nIf the method did not include a sort option, the method returns null .",
          "code_blocks": [
            "db. people . findAndModify ( { query : { name : \"Gus\" , state : \"active\" , rating : 100 } , sort : { rating : 1 } , update : { $inc : { score : 1 } } , upsert : true })",
            "{ }",
            "null"
          ]
        },
        {
          "subsection_id": "return-new-document",
          "heading": "Return New Document",
          "heading_level": 3,
          "content": "The following method includes both the upsert: true option and the new:true option. The method either updates a matching document and\nreturns the updated document or, if no matching document exists,\ninserts a document and returns the newly inserted document in the value field.\nIn the following example, no document in the people collection\nmatches the query condition:\nThe method returns the newly inserted document:",
          "code_blocks": [
            "db.people.findAndModify({ query: { name: \"Pascal\", state: \"active\", rating: 25 }, sort: { rating: 1 }, update: { $inc: { score: 1 } }, upsert: true, new: true })",
            "{ \"_id\" : ObjectId ( \"50f49ad6444c11ac2448a5d6\" ) , \"name\" : \"Pascal\" , \"rating\" : 25 , \"score\" : 1 , \"state\" : \"active\" }"
          ]
        },
        {
          "subsection_id": "sort-and-remove",
          "heading": "Sort and Remove",
          "heading_level": 3,
          "content": "By including a sort specification on the rating field, the\nfollowing example removes from the people collection a single\ndocument with the state value of active and the lowest rating among the matching documents:\nThe method returns the deleted document:",
          "code_blocks": [
            "db. people . findAndModify ( { query : { state : \"active\" } , sort : { rating : 1 } , remove : true } )",
            "{ \"_id\" : ObjectId ( \"52fba867ab5fdca1299674ad\" ) , \"name\" : \"XYZ123\" , \"score\" : 1 , \"state\" : \"active\" , \"rating\" : 3 }"
          ]
        },
        {
          "subsection_id": "specify-collation",
          "heading": "Specify Collation",
          "heading_level": 3,
          "content": "Collation allows users to specify\nlanguage-specific rules for string comparison, such as rules for\nlettercase and accent marks.\nA collection myColl has the following documents:\nThe following operation includes the collation option:\nThe operation returns the following document:",
          "code_blocks": [
            "{ _id : 1 , category : \"café\" , status : \"A\" } { _id : 2 , category : \"cafe\" , status : \"a\" } { _id : 3 , category : \"cafE\" , status : \"a\" }",
            "db. myColl . findAndModify ( { query : { category : \"cafe\" , status : \"a\" } , sort : { category : 1 } , update : { $set : { status : \"Updated\" } } , collation : { locale : \"fr\" , strength : 1 } }) ;",
            "{ \"_id\" : 1 , \"category\" : \"café\" , \"status\" : \"A\" }"
          ]
        },
        {
          "subsection_id": "specify-arrayfilters-for-an-array-update-operations",
          "heading": "Specify arrayFilters for an Array Update Operations",
          "heading_level": 3,
          "content": "",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "arrayFilters is not available for updates that use an\naggregation pipeline.\nWhen updating an array field, you can specify arrayFilters that\ndetermine which array elements to update.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "arrayFilters is not available for updates that use an\naggregation pipeline.\nCreate a collection students with the following documents:\nTo update all elements that are greater than or equal to 100 in the grades array, use the filtered positional operator $[<identifier>] with the arrayFilters option in the db.collection.findAndModify() method:\nThe operation updates the grades field for a single document, and\nafter the operation, the collection has the following documents:",
      "code_blocks": [
        "db. students . insertMany ( [ { \"_id\" : 1 , \"grades\" : [ 95 , 92 , 90 ] } , { \"_id\" : 2 , \"grades\" : [ 98 , 100 , 102 ] } , { \"_id\" : 3 , \"grades\" : [ 95 , 110 , 100 ] } ] )",
        "db. students . findAndModify ( { query : { grades : { $gte : 100 } } , update : { $set : { \"grades.$[element]\" : 100 } } , arrayFilters : [ { \"element\" : { $gte : 100 } } ] })",
        "{ \"_id\" : 1 , \"grades\" : [ 95 , 92 , 90 ] } { \"_id\" : 2 , \"grades\" : [ 98 , 100 , 100 ] } { \"_id\" : 3 , \"grades\" : [ 95 , 110 , 100 ] }"
      ],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "arrayFilters is not available for updates that use an\naggregation pipeline.\nCreate a collection students2 with the following documents:\nThe following operation finds a document where the _id field equals 1 and uses the filtered positional operator $[<identifier>] with\nthe arrayFilters to update the mean for all elements in the grades array where the grade is greater than or equal to 85 .\nThe operation updates the grades field for a single document, and after the\noperation, the collection has the following documents:",
      "code_blocks": [
        "db. students2 . insertMany ( [ { \"_id\" : 1 , \"grades\" : [ { \"grade\" : 80 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 85 , \"mean\" : 90 , \"std\" : 4 } , { \"grade\" : 85 , \"mean\" : 85 , \"std\" : 6 } ] } , { \"_id\" : 2 , \"grades\" : [ { \"grade\" : 90 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 87 , \"mean\" : 90 , \"std\" : 3 } , { \"grade\" : 85 , \"mean\" : 85 , \"std\" : 4 } ] } ] )",
        "db. students2 . findAndModify ( { query : { _id : 1 } , update : { $set : { \"grades.$[elem].mean\" : 100 } } , arrayFilters : [ { \"elem.grade\" : { $gte : 85 } } ] })",
        "{ \"_id\" : 1 , \"grades\" : [ { \"grade\" : 80 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 85 , \"mean\" : 100 , \"std\" : 4 } , { \"grade\" : 85 , \"mean\" : 100 , \"std\" : 6 } ] } { \"_id\" : 2 , \"grades\" : [ { \"grade\" : 90 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 87 , \"mean\" : 90 , \"std\" : 3 } , { \"grade\" : 85 , \"mean\" : 85 , \"std\" : 4 } ] }"
      ],
      "subsections": [
        {
          "subsection_id": "use-an-aggregation-pipeline-for-updates",
          "heading": "Use an Aggregation Pipeline for Updates",
          "heading_level": 3,
          "content": "db.collection.findAndModify() can accept an aggregation pipeline for\nthe update. The pipeline can consist of the following stages:\n- $addFields and its alias $set\n- $project and its alias $unset\n- $replaceRoot and its alias $replaceWith\n$addFields and its alias $set\n$project and its alias $unset\n$replaceRoot and its alias $replaceWith\nUsing the aggregation pipeline allows for a more expressive update\nstatement, such as expressing conditional updates based on current\nfield values or updating one field using the value of another field(s).\nFor example, create a collection students2 with the following documents:\nThe following operation finds a document where the _id field equals 1 and uses an aggregation pipeline to calculate a new field total from the grades field:",
          "code_blocks": [
            "db. students2 . insertMany ( [ { \"_id\" : 1 , \"grades\" : [ { \"grade\" : 80 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 85 , \"mean\" : 90 , \"std\" : 4 } , { \"grade\" : 85 , \"mean\" : 85 , \"std\" : 6 } ] } , { \"_id\" : 2 , \"grades\" : [ { \"grade\" : 90 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 87 , \"mean\" : 90 , \"std\" : 3 } , { \"grade\" : 85 , \"mean\" : 85 , \"std\" : 4 } ] } ] )",
            "db. students2 . findAndModify ( { query : { \"_id\" : 1 } , update : [ { $set : { \"total\" : { $sum : \"$grades.grade\" } } } ] , // The $set stage is an alias for ``$addFields`` stage new : true } )"
          ]
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "The $set used in the pipeline refers to the aggregation stage $set and not the update operator $set .\nThe operation returns the updated document:",
      "code_blocks": [
        "{ \"_id\" : 1 , \"grades\" : [ { \"grade\" : 80 , \"mean\" : 75 , \"std\" : 6 } , { \"grade\" : 85 , \"mean\" : 90 , \"std\" : 4 } , { \"grade\" : 85 , \"mean\" : 85 , \"std\" : 6 } ] , \"total\" : 250 }"
      ],
      "subsections": [
        {
          "subsection_id": "use-variables-in-let",
          "heading": "Use Variables in let",
          "heading_level": 3,
          "content": "New in version 5.0 .\nTo define variables that you can access elsewhere in the command, use\nthe let option.",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "To filter results using a variable, you must access the variable\nwithin the $expr operator.\nCreate a collection cakeFlavors :\nThe following example defines a targetFlavor variable in let and\nuses the variable to change the cake flavor from cherry to orange:",
      "code_blocks": [
        "db. cakeFlavors . insertMany ( [ { _id : 1 , flavor : \"chocolate\" } , { _id : 2 , flavor : \"strawberry\" } , { _id : 3 , flavor : \"cherry\" } ] )",
        "db. cakeFlavors . findAndModify ( { query : { $expr : { $eq : [ \"$flavor\" , \"$$targetFlavor\" ] } } , update : { flavor : \"orange\" } , let : { targetFlavor : \"cherry\" } } )"
      ],
      "subsections": [
        {
          "subsection_id": "user-roles-and-document-updates",
          "heading": "User Roles and Document Updates",
          "heading_level": 3,
          "content": "Starting in MongoDB 7.0, you can use the new USER_ROLES system variable to return user roles .\nThe example in this section shows updates to fields in a collection\ncontaining medical information. The example reads the current user roles\nfrom the USER_ROLES system variable and only performs the updates if\nthe user has a specific role.\nTo use a system variable, add $$ to the start of the variable name.\nSpecify the USER_ROLES system variable as $$USER_ROLES .\nThe example creates these users:\n- James with a Billing role.\n- Michelle with a Provider role.\nJames with a Billing role.\nMichelle with a Provider role.\nPerform the following steps to create the roles, users, and collection:\nCreate roles named Billing and Provider with the required\nprivileges and resources.\nRun:\nCreate users named James and Michelle with the required\nroles.\nRun:\nLog in as as Michelle , who has the Provider role, and perform an\nupdate:\nRun:\nThe previous example uses $setIntersection to return\ndocuments where the intersection between the \"Provider\" string and\nthe user roles from $$USER_ROLES.role is not empty. Michelle has\nthe Provider role, so the update is performed.\nNext, log in as as James , who does not have the Provider role,\nand attempt to perform the same update:\nRun:\nThe previous example does not update any documents.\ndb.collection.find\ndb.collection.findOne\n- Definition\n- Compatibility\n- Syntax\n- Return Data\n- Behavior\n- Examples\nReturn Data\nBehavior\n- Definition\n- Compatibility\n- Syntax\n- Return Data\n- Behavior\n- Examples\nReturn Data\nBehavior",
          "code_blocks": [
            "db. createRole ( { role : \"Billing\" , privileges : [ { resource : { db : \"test\" , collection : \"medicalView\" } , actions : [ \"find\" ] } ] , roles : [ ] } ) db. createRole ( { role : \"Provider\" , privileges : [ { resource : { db : \"test\" , collection : \"medicalView\" } , actions : [ \"find\" ] } ] , roles : [ ] } )",
            "db. createUser ( { user : \"James\" , pwd : \"js008\" , roles : [ { role : \"Billing\" , db : \"test\" } ] } ) db. createUser ( { user : \"Michelle\" , pwd : \"me009\" , roles : [ { role : \"Provider\" , db : \"test\" } ] } )",
            "db. medical . insertMany ( [ { _id : 0 , patientName : \"Jack Jones\" , diagnosisCode : \"CAS 17\" , creditCard : \"1234-5678-9012-3456\" } , { _id : 1 , patientName : \"Mary Smith\" , diagnosisCode : \"ACH 01\" , creditCard : \"6541-7534-9637-3456\" } ] )",
            "db. auth ( \"Michelle\" , \"me009\" )",
            "// Attempt to find and modify document db. medical . findAndModify ( { query : { $and : [ { // Only update the document for Mary Smith patientName : { $eq : \"Mary Smith\" } } , { // User must have the Provider role to perform the update $expr : { $ne : [ { $setIntersection : [ [ \"Provider\" ] , \"$$USER_ROLES.role\" ] } , [ ] ] } } ] } , // Update document update : { patientName : \"Mary Smith\" , diagnosisCode : \"ACH 03\" , creditCard : \"6541-7534-9637-3456\" } } )",
            "db. auth ( \"James\" , \"js008\" )",
            "// Attempt to find and modify document db. medical . findAndModify ( { query : { $and : [ { // Only update the document for Mary Smith patientName : { $eq : \"Mary Smith\" } } , { // User must have the Provider role to perform the update $expr : { $ne : [ { $setIntersection : [ [ \"Provider\" ] , \"$$USER_ROLES.role\" ] } , [ ] ] } } ] } , // Update document update : { patientName : \"Mary Smith\" , diagnosisCode : \"ACH 03\" , creditCard : \"6541-7534-9637-3456\" } } )"
          ]
        }
      ]
    }
  ],
  "fetched_at": "2025-12-09T03:46:22.933526",
  "exam_code": "associate_developer_python",
  "domain_id": 2,
  "domain_name": "CRUD",
  "seed_id": "find-and-modify",
  "source_type": "manual",
  "file_stub": "d2_find-and-modify"
}