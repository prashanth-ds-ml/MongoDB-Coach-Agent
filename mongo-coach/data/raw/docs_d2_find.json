{
  "url": "https://www.mongodb.com/docs/manual/reference/method/db.collection.find/",
  "doc_type": "mongodb_docs_method",
  "method_name": "db.collection.find",
  "title": "db.collection.find() (mongosh method)",
  "version": null,
  "breadcrumbs": [],
  "sections": [
    {
      "section_id": "definition",
      "heading": "Definition",
      "heading_level": 2,
      "content": "Selects documents in a collection or view and returns a cursor to the selected documents.",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "compatibility",
      "heading": "Compatibility",
      "heading_level": 2,
      "content": "This method is available in deployments hosted in the following environments:\n- MongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud\nMongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud\nMongoDB Atlas : The fully\nmanaged service for MongoDB deployments in the cloud",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "This command is supported in all MongoDB Atlas clusters.\nFor information on Atlas support for all commands, see Unsupported Commands .\n- MongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB\n- MongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB\nMongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB\nMongoDB Enterprise : The\nsubscription-based, self-managed version of MongoDB\nMongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB\nMongoDB Community : The\nsource-available, free-to-use, and self-managed version of MongoDB",
      "code_blocks": [],
      "subsections": []
    },
    {
      "section_id": "syntax",
      "heading": "Syntax",
      "heading_level": 2,
      "content": "The find() method has the following form:",
      "code_blocks": [
        "db. collection . find ( < query > , < projection > , < options > )"
      ],
      "subsections": [
        {
          "subsection_id": "parameters",
          "heading": "Parameters",
          "heading_level": 3,
          "content": "The find() method takes the following\nparameters:\nquery\ndocument\nOptional. Specifies selection filter using query\noperators . To return all\ndocuments in a collection, omit this parameter or pass an\nempty document ( {} ).\nprojection\ndocument\nOptional. Specifies the fields to return in the documents that match the\nquery filter. To return all fields in the matching documents, omit this\nparameter.  For details, see Projection .\noptions\ndocument\nOptional. Specifies additional options for the query. These options\nmodify query behavior and how results are returned. For details,\nsee Options .",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "behavior",
      "heading": "Behavior",
      "heading_level": 2,
      "content": "",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "projection",
          "heading": "Projection",
          "heading_level": 3,
          "content": "",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "important",
      "heading": "Important",
      "heading_level": 2,
      "content": "",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "language-consistency",
          "heading": "Language Consistency",
          "heading_level": 3,
          "content": "As part of making find() and findAndModify() projection consistent with\naggregation's $project stage,\n- The find() and findAndModify() projection can accept aggregation expressions and syntax .\n- MongoDB enforces additional restrictions with regards to\nprojections. See Projection Restrictions for details.\nThe find() and findAndModify() projection can accept aggregation expressions and syntax .\nMongoDB enforces additional restrictions with regards to\nprojections. See Projection Restrictions for details.\nMongoDB enforces additional restrictions with regards to\nprojections. See Projection Restrictions for details.\nThe projection parameter determines which fields are returned in\nthe matching documents. The projection parameter takes a document\nof the following form:\n<field>: <1 or true>\nSpecifies the inclusion of a field. If you specify a non-zero\ninteger for the projection value, the operation treats the\nvalue as true .\n<field>: <0 or false>\nSpecifies the exclusion of a field.\n\"<field>.$\": <1 or true>\nUses the $ array projection operator to return\nthe first element that matches the query condition on the\narray field. If you specify a non-zero integer for the\nprojection value, the operation treats the value as true .\nNot available for views .\n<field>: <array projection>\nUses the array projection operators ( $elemMatch , $slice ) to specify the array elements to\ninclude.\nNot available for views .\n<field>: <$meta expression>\nUses the $meta operator expression to specify\nthe inclusion of available per-document metadata .\nNot available for views .\n<field>: <aggregation expression>\nSpecifies the value of the projected field.\nWith the use of aggregation expressions and syntax , including the use of literals and\naggregation variables, you can project new fields or project existing\nfields with new values.\n- If you specify a non-numeric, non-boolean literal (such as a\nliteral string or an array or an operator expression) for\nthe projection value, the field is projected with the new\nvalue, for example: { field: [ 1, 2, 3, \"$someExistingField\" ] } { field: \"New String Value\" } { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\n- { field: [ 1, 2, 3, \"$someExistingField\" ] }\n- { field: \"New String Value\" }\n- { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\n- To project a literal value for a field, use the $literal aggregation expression; for example: { field: { $literal: 5 } } { field: { $literal: true } } { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\n- { field: { $literal: 5 } }\n- { field: { $literal: true } }\n- { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\nIf you specify a non-numeric, non-boolean literal (such as a\nliteral string or an array or an operator expression) for\nthe projection value, the field is projected with the new\nvalue, for example: { field: [ 1, 2, 3, \"$someExistingField\" ] } { field: \"New String Value\" } { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\nIf you specify a non-numeric, non-boolean literal (such as a\nliteral string or an array or an operator expression) for\nthe projection value, the field is projected with the new\nvalue, for example:\n- { field: [ 1, 2, 3, \"$someExistingField\" ] }\n- { field: \"New String Value\" }\n- { field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\n{ field: [ 1, 2, 3, \"$someExistingField\" ] }\n{ field: \"New String Value\" }\n{ field: { status: \"Active\", total: { $sum: \"$existingArray\" } } }\nTo project a literal value for a field, use the $literal aggregation expression; for example: { field: { $literal: 5 } } { field: { $literal: true } } { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\nTo project a literal value for a field, use the $literal aggregation expression; for example:\n- { field: { $literal: 5 } }\n- { field: { $literal: true } }\n- { field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }\n{ field: { $literal: 5 } }\n{ field: { $literal: true } }\n{ field: { $literal: { fieldWithValue0: 0, fieldWithValue1: 1 } } }",
          "code_blocks": [
            "{ < field1 > : < value > , < field2 > : < value > ... }"
          ]
        },
        {
          "subsection_id": "options",
          "heading": "Options",
          "heading_level": 3,
          "content": "allowDiskUse\nWhether or not pipelines that require more than 100 megabytes of\nmemory to execute write to temporary files on disk. For details,\nsee cursor.allowDiskUse() .\nallowPartialResults\nFor queries against a sharded collection, allows the command\n(or subsequent getMore commands) to return partial results,\nrather than an error, if one or more queried shards are\nunavailable.\nawaitData\nIf the cursor is a a tailable-await cursor.\nRequires tailable to be true .\ncollation\nCollation settings for update operation.\ncomment\nAdds a $comment to the query that shows in the profiler logs.\nexplain\nAdds explain output based on the verbosity mode provided.\nhint\nForces the query optimizer to use specific indexes in the\nquery.\nlimit\nSets a limit of documents returned in the result set.\nmax\nThe exclusive upper bound for a specific index.\nmaxAwaitTimeMS\nThe maximum amount of time for the server to wait on\nnew documents to satisfy a tailable cursor query. Requires tailable and awaitData to be true .\nmaxTimeMS\nThe maximum amount of time (in milliseconds) the\nserver should allow the query to run.\nmin\nThe inclusive lower bound for a specific index.\nnoCursorTimeout\nWhether the server should timeout the cursor\nafter a period of inactivity (by default 10 minutes).\nprojection\nSpecifies the fields to return in the documents that match the query filter.\nYou can specify projection in two ways for find() and findOne() :\n- Setting the projection parameter\n- Setting the options parameter to projection\nSetting the projection parameter\nSetting the options parameter to projection\nIf you specify both parameters, the projection parameter takes precedence. To use options.projection , set the projection parameter to null or undefined .\nreadConcern\nSpecifies the read concern level for the query.\nreadPreference\nSpecifies the read preference level for the query.\nreturnKey\nWhether only the index keys are returned for a\nquery.\nshowRecordId\nIf the $recordId field is added to the returned\ndocuments. The $recordId indicates the position of the\ndocument in the result set.\nskip\nHow many documents to skip before returning the\nfirst document in the result set.\nsort\nThe order of the documents returned in the result\nset. Fields specified in the sort, must have an index.\ntailable\nIndicates if the cursor is tailable. Tailable cursors remain\nopen after the intial results of the query are exhausted.\nTailable cursors are only available on Capped Collections .\nFor fields in an embedded documents, you can specify the field using\neither:\n- dot notation , for example \"field.nestedfield\": <value>\n- nested form, for example { field: { nestedfield: <value> } }\ndot notation , for example \"field.nestedfield\": <value>\nnested form, for example { field: { nestedfield: <value> } }\nThe _id field is included in the returned documents by default unless\nyou explicitly specify _id: 0 in the projection to suppress the field.\nA projection cannot contain both include and exclude\nspecifications, with the exception of the _id field:\n- In projections that explicitly include fields, the _id field is\nthe only field that you can explicitly exclude .\n- In projections that explicitly excludes fields, the _id field\nis the only field that you can explicitly include ; however, the _id field is included by default.\nIn projections that explicitly include fields, the _id field is\nthe only field that you can explicitly exclude .\nIn projections that explicitly include fields, the _id field is\nthe only field that you can explicitly exclude .\nIn projections that explicitly excludes fields, the _id field\nis the only field that you can explicitly include ; however, the _id field is included by default.\nIn projections that explicitly excludes fields, the _id field\nis the only field that you can explicitly include ; however, the _id field is included by default.\nSee Projection Examples .\nWhen an operation both sorts and projects with the same\nfields, MongoDB sorts on the original field values before applying the\nprojection. For more information about operation order, see find() Order\nof Operations .",
          "code_blocks": []
        },
        {
          "subsection_id": "cursor-handling",
          "heading": "Cursor Handling",
          "heading_level": 3,
          "content": "Executing db.collection.find() in mongosh automatically iterates the cursor to display up to the first 20\ndocuments. Type it to continue iteration.\nTo access the returned documents with a driver, use the appropriate\ncursor handling mechanism for the driver language .",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "tip",
      "heading": "Tip",
      "heading_level": 2,
      "content": "- Iterate the Returned Cursor\n- Modify the Cursor Behavior\n- Available mongosh Cursor Methods\nIterate the Returned Cursor\nModify the Cursor Behavior\nAvailable mongosh Cursor Methods",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "read-concern",
          "heading": "Read Concern",
          "heading_level": 3,
          "content": "To specify the read concern for db.collection.find() , use the cursor.readConcern() method.",
          "code_blocks": []
        },
        {
          "subsection_id": "type-bracketing",
          "heading": "Type Bracketing",
          "heading_level": 3,
          "content": "MongoDB treats some data types as equivalent for comparison purposes.\nFor instance, numeric types undergo conversion before comparison. For\nmost data types, however, comparison operators only\nperform comparisons on documents where the BSON type of the\ntarget field matches the type of the query operand. Consider the\nfollowing collection:\nThe following query uses $gt to return documents where the\nvalue of qty is greater than 4 .\nThe query returns the following documents:\nThe document with _id equal to \"avocados\" is not\nreturned because its qty value is of type string while the $gt operand is of type integer .\nThe document with _id equal to \"oranges\" is not returned\nbecause its qty value is of type object .",
          "code_blocks": [
            "{ \"_id\" : \"apples\" , \"qty\" : 5 } { \"_id\" : \"bananas\" , \"qty\" : 7 } { \"_id\" : \"oranges\" , \"qty\" : { \"in stock\" : 8 , \"ordered\" : 12 } } { \"_id\" : \"avocados\" , \"qty\" : \"fourteen\" }",
            "db. collection . find ( { qty : { $gt : 4 } } )",
            "{ \"_id\" : \"apples\" , \"qty\" : 5 } { \"_id\" : \"bananas\" , \"qty\" : 7 }"
          ]
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "To enforce data types in a collection, use Schema Validation .",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "sessions",
          "heading": "Sessions",
          "heading_level": 3,
          "content": "For cursors created inside a session, you cannot call getMore outside the session.\nSimilarly, for cursors created outside of a session, you cannot call getMore inside a session.\nMongoDB drivers and mongosh associate all operations with a server session , with the exception of unacknowledged\nwrite operations. For operations not explicitly associated with a\nsession (i.e. using Mongo.startSession() ), MongoDB drivers\nand mongosh create an implicit session and associate it\nwith the operation.\nIf a session is idle for longer than 30 minutes, the MongoDB server\nmarks that session as expired and may close it at any time. When the\nMongoDB server closes the session, it also kills any in-progress\noperations and open cursors associated with the session. This\nincludes cursors configured with noCursorTimeout() or\na maxTimeMS() greater than 30 minutes.\nFor operations that may be idle for longer than 30 minutes, associate\nthe operation with an explicit session using Mongo.startSession() and periodically refresh the session\nusing the refreshSessions command. See Session Idle Timeout for more information.",
          "code_blocks": []
        },
        {
          "subsection_id": "transactions",
          "heading": "Transactions",
          "heading_level": 3,
          "content": "db.collection.find() can be used inside distributed transactions .\n- For cursors created outside of a transaction, you cannot call getMore inside the transaction.\n- For cursors created in a transaction, you cannot call getMore outside the transaction.\nFor cursors created outside of a transaction, you cannot call getMore inside the transaction.\nFor cursors created in a transaction, you cannot call getMore outside the transaction.",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "important",
      "heading": "Important",
      "heading_level": 2,
      "content": "In most cases, a distributed transaction incurs a greater\nperformance cost over single document writes, and the\navailability of distributed transactions should not be a\nreplacement for effective schema design. For many scenarios, the denormalized data model (embedded documents and arrays) will continue to be optimal for your\ndata and use cases. That is, for many scenarios, modeling your data\nappropriately will minimize the need for distributed\ntransactions.\nFor additional transactions usage considerations\n(such as runtime limit and oplog size limit), see also Production Considerations .",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "client-disconnection",
          "heading": "Client Disconnection",
          "heading_level": 3,
          "content": "If the client that issued db.collection.find() disconnects before the operation\ncompletes, MongoDB marks db.collection.find() for termination using killOp .",
          "code_blocks": []
        },
        {
          "subsection_id": "query-settings",
          "heading": "Query Settings",
          "heading_level": 3,
          "content": "New in version 8.0 .\nYou can use query settings to set index hints, set operation\nrejection filters , and other fields. The\nsettings apply to the query shape on the\nentire cluster. The cluster retains the settings after shutdown.\nThe query optimizer uses the query settings as an additional\ninput during query planning, which affects the plan selected to run the\nquery. You can also use query settings to block a query shape.\nTo add query settings and explore examples, see setQuerySettings .\nYou can add query settings for find , distinct ,\nand aggregate commands.\nQuery settings have more functionality and are preferred over\ndeprecated index filters .\nTo remove query settings, use removeQuerySettings . To\nobtain the query settings, use a $querySettings stage in an\naggregation pipeline.",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "examples",
      "heading": "Examples",
      "heading_level": 2,
      "content": "The examples in this section use documents from the bios\ncollection where the documents\ngenerally have the form:\nTo create and populate the bios collection, see bios collection .",
      "code_blocks": [
        "{ \"_id\" : < value > , \"name\" : { \"first\" : < string > , \"last\" : < string > } , // embedded document \"birth\" : < ISODate > , \"death\" : < ISODate > , \"contribs\" : [ < string > , ... ] , // Array of Strings \"awards\" : [ { \"award\" : < string > , year : < number > , by : < string > } // Array of embedded documents ... ] }"
      ],
      "subsections": [
        {
          "subsection_id": "find-all-documents-in-a-collection",
          "heading": "Find All Documents in a Collection",
          "heading_level": 3,
          "content": "The find() method with no parameters\nreturns all documents from a collection and returns all fields for the\ndocuments. For example, the following operation returns all documents in\nthe bios collection :",
          "code_blocks": [
            "db. bios . find ( )"
          ]
        },
        {
          "subsection_id": "find-documents-that-match-query-criteria",
          "heading": "Find Documents that Match Query Criteria",
          "heading_level": 3,
          "content": "- The following operation returns documents in the bios\ncollection where _id equals 5 : db. bios . find ( { _id : 5 } )\n- The following operation returns documents in the bios\ncollection where the field last in the name embedded document equals \"Hopper\" : db. bios . find ( { \"name.last\" : \"Hopper\" } ) Note To access fields in an embedded document, use dot notation ( \"<embedded\ndocument>.<field>\" ).\nThe following operation returns documents in the bios\ncollection where _id equals 5 : db. bios . find ( { _id : 5 } )\nThe following operation returns documents in the bios\ncollection where _id equals 5 :\nThe following operation returns documents in the bios\ncollection where the field last in the name embedded document equals \"Hopper\" : db. bios . find ( { \"name.last\" : \"Hopper\" } ) Note To access fields in an embedded document, use dot notation ( \"<embedded\ndocument>.<field>\" ).\nThe following operation returns documents in the bios\ncollection where the field last in the name embedded document equals \"Hopper\" :",
          "code_blocks": [
            "db. bios . find ( { _id : 5 } )",
            "db. bios . find ( { \"name.last\" : \"Hopper\" } )"
          ]
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "To access fields in an embedded document, use dot notation ( \"<embedded\ndocument>.<field>\" ).\nTo find documents that match a set of selection criteria, call find() with the <criteria> parameter.\nMongoDB provides various query operators to\nspecify the criteria.\n- The following operation uses the $in operator to return\ndocuments in the bios collection where _id equals either 5 or ObjectId(\"507c35dd8fada716c89d0013\") : db. bios . find ( { _id : { $in : [ 5 , ObjectId ( \"507c35dd8fada716c89d0013\" ) ] } } )\n- The following operation uses the $gt operator returns all\nthe documents from the bios collection where birth is\ngreater than new Date('1950-01-01') : db. bios . find ( { birth : { $gt : new Date ( '1950-01-01' ) } } )\n- The following operation uses the $regex operator to return\ndocuments in the bios collection where name.last field\nstarts with the letter N (or is \"LIKE N%\" ) db. bios . find ( { \"name.last\" : { $regex : /^N/ } } )\nThe following operation uses the $in operator to return\ndocuments in the bios collection where _id equals either 5 or ObjectId(\"507c35dd8fada716c89d0013\") : db. bios . find ( { _id : { $in : [ 5 , ObjectId ( \"507c35dd8fada716c89d0013\" ) ] } } )\nThe following operation uses the $in operator to return\ndocuments in the bios collection where _id equals either 5 or ObjectId(\"507c35dd8fada716c89d0013\") :\nThe following operation uses the $gt operator returns all\nthe documents from the bios collection where birth is\ngreater than new Date('1950-01-01') : db. bios . find ( { birth : { $gt : new Date ( '1950-01-01' ) } } )\nThe following operation uses the $gt operator returns all\nthe documents from the bios collection where birth is\ngreater than new Date('1950-01-01') :\nThe following operation uses the $regex operator to return\ndocuments in the bios collection where name.last field\nstarts with the letter N (or is \"LIKE N%\" ) db. bios . find ( { \"name.last\" : { $regex : /^N/ } } )\nThe following operation uses the $regex operator to return\ndocuments in the bios collection where name.last field\nstarts with the letter N (or is \"LIKE N%\" )\nFor a list of the query operators, see Query Predicates .\nCombine comparison operators to specify ranges for a field. The\nfollowing operation returns from the bios collection documents where birth is\nbetween new Date('1940-01-01') and new Date('1960-01-01') (exclusive):\nFor a list of the query operators, see Query Predicates .\nThe following operation returns all the documents from the bios\ncollection where birth field\nis greater than new Date('1950-01-01') and death field does not exists:\nFor a list of the query operators, see Query Predicates .",
      "code_blocks": [
        "db. bios . find ( { _id : { $in : [ 5 , ObjectId ( \"507c35dd8fada716c89d0013\" ) ] } } )",
        "db. bios . find ( { birth : { $gt : new Date ( '1950-01-01' ) } } )",
        "db. bios . find ( { \"name.last\" : { $regex : /^N/ } } )",
        "db. bios . find ( { birth : { $gt : new Date ( '1940-01-01' ) , $lt : new Date ( '1960-01-01' ) } } )",
        "db. bios . find ( { birth : { $gt : new Date ( '1920-01-01' ) } , death : { $exists : false } } )"
      ],
      "subsections": [
        {
          "subsection_id": "compare-two-fields-from-a-single-document",
          "heading": "Compare Two Fields from A Single Document",
          "heading_level": 3,
          "content": "$expr can contain expressions that compare fields from the same\ndocument.\nCreate a monthlyBudget collection with these documents:\nThe following operation uses $expr to find documents\nwhere the spent amount exceeds the budget :\nOutput:",
          "code_blocks": [
            "db. monthlyBudget . insertMany ( [ { _id : 1 , category : \"food\" , budget : 400 , spent : 450 } , { _id : 2 , category : \"drinks\" , budget : 100 , spent : 150 } , { _id : 3 , category : \"clothes\" , budget : 100 , spent : 50 } , { _id : 4 , category : \"misc\" , budget : 500 , spent : 300 } , { _id : 5 , category : \"travel\" , budget : 200 , spent : 650 } ] )",
            "db. monthlyBudget . find ( { $expr : { $gt : [ \"$spent\" , \"$budget\" ] } } )",
            "{ _id : 1 , category : \"food\" , budget : 400 , spent : 450 } { _id : 2 , category : \"drinks\" , budget : 100 , spent : 150 } { _id : 5 , category : \"travel\" , budget : 200 , spent : 650 }"
          ]
        },
        {
          "subsection_id": "query-embedded-documents",
          "heading": "Query Embedded Documents",
          "heading_level": 3,
          "content": "The following examples query the name embedded field in the bios collection .\nThe following operation returns documents in the bios collection where the embedded document name is exactly { first: \"Yukihiro\", last: \"Matsumoto\" } , including the\norder:\nThe name field must match the embedded document exactly. The query does not match documents with the following name fields:\nThe following operation returns documents in the bios collection where the embedded document name contains a field first with the value \"Yukihiro\" and a field last with the value \"Matsumoto\" . The query uses dot notation to access fields in an embedded document:\nThe query matches the document where the name field contains an\nembedded document with the field first with the value \"Yukihiro\" and a\nfield last with the value \"Matsumoto\" . For instance, the query\nwould match documents with name fields that held either of the\nfollowing values:\nFor more information and examples, see also Query on Embedded/Nested Documents .",
          "code_blocks": [
            "db. bios . find ( { name : { first : \"Yukihiro\" , last : \"Matsumoto\" } } )",
            "{ first : \"Yukihiro\" , aka : \"Matz\" , last : \"Matsumoto\" } { last : \"Matsumoto\" , first : \"Yukihiro\" }",
            "db. bios . find ( { \"name.first\" : \"Yukihiro\" , \"name.last\" : \"Matsumoto\" } )",
            "{ first : \"Yukihiro\" , aka : \"Matz\" , last : \"Matsumoto\" } { last : \"Matsumoto\" , first : \"Yukihiro\" }"
          ]
        },
        {
          "subsection_id": "query-arrays",
          "heading": "Query Arrays",
          "heading_level": 3,
          "content": "The following examples query the contribs array in the bios\ncollection .\n- The following operation returns documents in the bios\ncollection where the array\nfield contribs contains the element \"UNIX\" : db. bios . find ( { contribs : \"UNIX\" } )\n- The following operation returns documents in the bios\ncollection where the array\nfield contribs contains the element \"ALGOL\" or \"Lisp\" : db. bios . find ( { contribs : { $in : [ \"ALGOL\" , \"Lisp\" ]} } )\n- The following operation use the $all query operator to\nreturn documents in the bios collection where the array field contribs contains both the elements \"ALGOL\" and \"Lisp\" : db. bios . find ( { contribs : { $all : [ \"ALGOL\" , \"Lisp\" ] } } ) For more examples, see $all .  See also $elemMatch .\n- The following operation uses the $size operator to return\ndocuments in the bios collection where the array size\nof contribs is 4: db. bios . find ( { contribs : { $size : 4 } } )\nThe following operation returns documents in the bios\ncollection where the array\nfield contribs contains the element \"UNIX\" : db. bios . find ( { contribs : \"UNIX\" } )\nThe following operation returns documents in the bios\ncollection where the array\nfield contribs contains the element \"UNIX\" :\nThe following operation returns documents in the bios\ncollection where the array\nfield contribs contains the element \"ALGOL\" or \"Lisp\" : db. bios . find ( { contribs : { $in : [ \"ALGOL\" , \"Lisp\" ]} } )\nThe following operation returns documents in the bios\ncollection where the array\nfield contribs contains the element \"ALGOL\" or \"Lisp\" :\nThe following operation use the $all query operator to\nreturn documents in the bios collection where the array field contribs contains both the elements \"ALGOL\" and \"Lisp\" : db. bios . find ( { contribs : { $all : [ \"ALGOL\" , \"Lisp\" ] } } ) For more examples, see $all .  See also $elemMatch .\nThe following operation use the $all query operator to\nreturn documents in the bios collection where the array field contribs contains both the elements \"ALGOL\" and \"Lisp\" :\nFor more examples, see $all .  See also $elemMatch .\nThe following operation uses the $size operator to return\ndocuments in the bios collection where the array size\nof contribs is 4: db. bios . find ( { contribs : { $size : 4 } } )\nThe following operation uses the $size operator to return\ndocuments in the bios collection where the array size\nof contribs is 4:\nFor more information and examples of querying an array, see:\n- Query an Array\n- Query an Array of Embedded Documents\nQuery an Array\nQuery an Array of Embedded Documents\nFor a list of array specific query operators, see Array Query Predicate Operators .\nThe following examples query the awards array in the bios\ncollection .\n- The following operation returns documents in the bios\ncollection where the awards array contains an element with award field equals \"Turing Award\" : db. bios . find ( { \"awards.award\" : \"Turing Award\" } )\n- The following operation returns documents in the bios\ncollection where the awards array contains at least one element with both the award field\nequals \"Turing Award\" and the year field greater than 1980: db. bios . find ( { awards : { $elemMatch : { award : \"Turing Award\" , year : { $gt : 1980 } } } } ) Use the $elemMatch operator to specify multiple criteria on\nan array element.\nThe following operation returns documents in the bios\ncollection where the awards array contains an element with award field equals \"Turing Award\" : db. bios . find ( { \"awards.award\" : \"Turing Award\" } )\nThe following operation returns documents in the bios\ncollection where the awards array contains an element with award field equals \"Turing Award\" :\nThe following operation returns documents in the bios\ncollection where the awards array contains at least one element with both the award field\nequals \"Turing Award\" and the year field greater than 1980: db. bios . find ( { awards : { $elemMatch : { award : \"Turing Award\" , year : { $gt : 1980 } } } } ) Use the $elemMatch operator to specify multiple criteria on\nan array element.\nThe following operation returns documents in the bios\ncollection where the awards array contains at least one element with both the award field\nequals \"Turing Award\" and the year field greater than 1980:\nUse the $elemMatch operator to specify multiple criteria on\nan array element.\nFor more information and examples of querying an array, see:\n- Query an Array\n- Query an Array of Embedded Documents\nQuery an Array\nQuery an Array of Embedded Documents\nFor a list of array specific query operators, see Array Query Predicate Operators .",
          "code_blocks": [
            "db. bios . find ( { contribs : \"UNIX\" } )",
            "db. bios . find ( { contribs : { $in : [ \"ALGOL\" , \"Lisp\" ]} } )",
            "db. bios . find ( { contribs : { $all : [ \"ALGOL\" , \"Lisp\" ] } } )",
            "db. bios . find ( { contribs : { $size : 4 } } )",
            "db. bios . find ( { \"awards.award\" : \"Turing Award\" } )",
            "db. bios . find ( { awards : { $elemMatch : { award : \"Turing Award\" , year : { $gt : 1980 } } } } )"
          ]
        },
        {
          "subsection_id": "query-for-bson-regular-expressions",
          "heading": "Query for BSON Regular Expressions",
          "heading_level": 3,
          "content": "To find documents that contain BSON regular expressions as values, call find() with the bsonRegExp option set to true . The bsonRegExp option allows you to return regular\nexpressions that can't be represented as JavaScript regular expressions.\nThe following operation returns documents in a collection named testbson where the value of a field named foo is a BSONRegExp type:",
          "code_blocks": [
            "db. testbson . find ( { } , { } , { bsonRegExp : true } )",
            "[ { _id : ObjectId ( '65e8ba8a4b3c33a76e6cacca' ) , foo : BSONRegExp ( '(?-i)AA_' , 'i' ) } ]"
          ]
        },
        {
          "subsection_id": "projections",
          "heading": "Projections",
          "heading_level": 3,
          "content": "The projection parameter specifies which fields\nto return. The parameter contains either include or exclude\nspecifications, not both, unless the exclude is for the _id field.",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "Unless the _id field is explicitly excluded in the projection\ndocument _id: 0 , the _id field is returned.\nThe following operation finds all documents in the bios collection and returns only the name field, contribs field and _id field:",
      "code_blocks": [
        "db. bios . find ( { } , { name : 1 , contribs : 1 } )"
      ],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "Unless the _id field is explicitly excluded in the projection\ndocument _id: 0 , the _id field is returned.\nThe following operation queries the bios collection and returns all fields except the first field in the name embedded document and the birth field:",
      "code_blocks": [
        "db. bios . find ( { contribs : 'OOP' } , { 'name.first' : 0 , birth : 0 } )"
      ],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "Unless the _id field is explicitly excluded in the projection\ndocument _id: 0 , the _id field is returned.\nThe following operation finds documents in the bios collection and returns only the name field and the contribs field:\nThe following operation queries the bios collection and returns the last field in\nthe name embedded document and the first two elements in the contribs array:\nYou can also specify embedded fields using the nested form. For example:\ndb.collection.find() projection can accept aggregation expressions and syntax .\nWith the use of aggregation expressions and syntax, you can project new\nfields or project existing fields with new values. For example, the\nfollowing operation uses aggregation expressions to override the value\nof the name and awards fields as well as to include new fields reportDate , reportBy , and reportNumber .\nTo set the reportRun field to the value 1 The operation returns the following documents:",
      "code_blocks": [
        "db. bios . find ( { } , { name : 1 , contribs : 1 , _id : 0 } )",
        "db. bios . find ( { } , { _id : 0 , 'name.last' : 1 , contribs : { $slice : 2 } } )",
        "db. bios . find ( { } , { _id : 0 , name : { last : 1 } , contribs : { $slice : 2 } } )",
        "db. bios . find ( { } , { _id : 0 , name : { $concat : [ { $ifNull : [ \"$name.aka\" , \"$name.first\" ] } , \" \" , \"$name.last\" ] } , birth : 1 , contribs : 1 , awards : { $cond : { if : { $isArray : \"$awards\" } , then : { $size : \"$awards\" } , else : 0 } } , reportDate : { $dateToString : { date : new Date ( ) , format : \"%Y-%m-%d\" } } , reportBy : \"hellouser123\" , reportNumber : { $literal : 1 } } )",
        "{ \"birth\" : ISODate ( \"1924-12-03T05:00:00Z\" ) , \"contribs\" : [ \"Fortran\" , \"ALGOL\" , \"Backus-Naur Form\" , \"FP\" ] , \"name\" : \"John Backus\" , \"awards\" : 4 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1927-09-04T04:00:00Z\" ) , \"contribs\" : [ \"Lisp\" , \"Artificial Intelligence\" , \"ALGOL\" ] , \"name\" : \"John McCarthy\" , \"awards\" : 3 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1906-12-09T05:00:00Z\" ) , \"contribs\" : [ \"UNIVAC\" , \"compiler\" , \"FLOW-MATIC\" , \"COBOL\" ] , \"name\" : \"Grace Hopper\" , \"awards\" : 4 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1926-08-27T04:00:00Z\" ) , \"contribs\" : [ \"OOP\" , \"Simula\" ] , \"name\" : \"Kristen Nygaard\" , \"awards\" : 3 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1931-10-12T04:00:00Z\" ) , \"contribs\" : [ \"OOP\" , \"Simula\" ] , \"name\" : \"Ole-Johan Dahl\" , \"awards\" : 3 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1956-01-31T05:00:00Z\" ) , \"contribs\" : [ \"Python\" ] , \"name\" : \"Guido van Rossum\" , \"awards\" : 2 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1941-09-09T04:00:00Z\" ) , \"contribs\" : [ \"UNIX\" , \"C\" ] , \"name\" : \"Dennis Ritchie\" , \"awards\" : 3 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1965-04-14T04:00:00Z\" ) , \"contribs\" : [ \"Ruby\" ] , \"name\" : \"Matz Matsumoto\" , \"awards\" : 1 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"birth\" : ISODate ( \"1955-05-19T04:00:00Z\" ) , \"contribs\" : [ \"Java\" ] , \"name\" : \"James Gosling\" , \"awards\" : 2 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 } { \"contribs\" : [ \"Scala\" ] , \"name\" : \"Martin Odersky\" , \"awards\" : 0 , \"reportDate\" : \"2020-06-05\" , \"reportBy\" : \"hellouser123\" , \"reportNumber\" : 1 }"
      ],
      "subsections": []
    },
    {
      "section_id": "tip",
      "heading": "Tip",
      "heading_level": 2,
      "content": "Project Fields to Return from Query",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "iterate-the-returned-cursor",
          "heading": "Iterate the Returned Cursor",
          "heading_level": 3,
          "content": "The find() method returns a cursor to the results.\nIn mongosh , if the returned cursor is not assigned to a\nvariable using the var keyword, the cursor is automatically iterated to\naccess up to the first 20 documents that match the query. You can update the displayBatchSize variable to change the number of automatically\niterated documents.\nThe following example sets the batch size to 3. Future db.collection.find() operations will only return 3 documents per cursor iteration.\nTo manually iterate over the results, assign the returned cursor to a variable\nwith the var keyword, as shown in the following sections.\nThe following example uses the variable myCursor to iterate over the\ncursor and print the matching documents:\nThe following example uses the cursor method next() to\naccess the documents:\nTo print, you can also use the printjson() method instead of print(tojson()) :\nThe following example uses the cursor method forEach() to iterate the cursor and access the documents:",
          "code_blocks": [
            "config. set ( \"displayBatchSize\" , 3 )",
            "var myCursor = db. bios . find ( ) ; myCursor",
            "var myCursor = db. bios . find ( ) ; var myDocument = myCursor. hasNext ( ) ? myCursor. next ( ) : null ; if ( myDocument) { var myName = myDocument. name ; print ( tojson ( myName)) ; }",
            "if ( myDocument) { var myName = myDocument. name ; printjson ( myName) ; }",
            "var myCursor = db. bios . find ( ) ; myCursor. forEach ( printjson) ;"
          ]
        },
        {
          "subsection_id": "modify-the-cursor-behavior",
          "heading": "Modify the Cursor Behavior",
          "heading_level": 3,
          "content": "mongosh and the drivers provide several cursor methods that call on the cursor returned by the find() method to\nmodify its behavior.\nThe sort() method orders the documents in the result\nset. The following operation returns documents in the bios\ncollection sorted in ascending\norder by the name field:\nsort() corresponds to the ORDER BY statement in SQL.\nThe limit() method limits the number of documents in\nthe result set. The following operation returns at most 5 documents\nin the bios collection :\nlimit() corresponds to the LIMIT statement in SQL.\nThe skip() method controls the starting point of the\nresults set. The following operation skips the first 5 documents in\nthe bios collection and\nreturns all remaining documents:\nCollation allows users to specify\nlanguage-specific rules for string comparison, such as rules for\nlettercase and accent marks.\nThe collation() method specifies the collation for the db.collection.find() operation.\nThe following statements chain cursor methods limit() and sort() :\nThe two statements are equivalent; i.e. the order in which you chain\nthe limit() and the sort() methods\nis not significant. Both statements return the first five documents, as\ndetermined by the ascending sort order on 'name'.\n- cursor.allowDiskUse()\n- cursor.batchSize()\n- cursor.close()\n- cursor.isClosed()\n- cursor.collation()\n- cursor.comment()\n- cursor.count()\n- cursor.explain()\n- cursor.forEach()\n- cursor.hasNext()\n- cursor.hint()\n- cursor.isExhausted()\n- cursor.itcount()\n- cursor.limit()\n- cursor.map()\n- cursor.max()\ncursor.allowDiskUse()\ncursor.batchSize()\ncursor.close()\ncursor.isClosed()\ncursor.collation()\ncursor.comment()\ncursor.count()\ncursor.explain()\ncursor.forEach()\ncursor.hasNext()\ncursor.hint()\ncursor.isExhausted()\ncursor.itcount()\ncursor.limit()\ncursor.map()\ncursor.max()\n- cursor.maxTimeMS()\n- cursor.min()\n- cursor.next()\n- cursor.noCursorTimeout()\n- cursor.objsLeftInBatch()\n- cursor.pretty()\n- cursor.readConcern()\n- cursor.readPref()\n- cursor.returnKey()\n- cursor.showRecordId()\n- cursor.size()\n- cursor.skip()\n- cursor.sort()\n- cursor.tailable()\n- cursor.toArray()\ncursor.maxTimeMS()\ncursor.min()\ncursor.next()\ncursor.noCursorTimeout()\ncursor.objsLeftInBatch()\ncursor.pretty()\ncursor.readConcern()\ncursor.readPref()\ncursor.returnKey()\ncursor.showRecordId()\ncursor.size()\ncursor.skip()\ncursor.sort()\ncursor.tailable()\ncursor.toArray()",
          "code_blocks": [
            "db. bios . find ( ). sort ( { name : 1 } )",
            "db. bios . find ( ). limit ( 5 )",
            "db. bios . find ( ). skip ( 5 )",
            "db. bios . find ( { \"name.last\" : \"hopper\" } ). collation ( { locale : \"en_US\" , strength : 1 } )",
            "db. bios . find ( ). sort ( { name : 1 } ). limit ( 5 ) db. bios . find ( ). limit ( 5 ). sort ( { name : 1 } )"
          ]
        },
        {
          "subsection_id": "use-variables-in-let-option",
          "heading": "Use Variables in let Option",
          "heading_level": 3,
          "content": "You can specify query options to modify query behavior and indicate how\nresults are returned.\nFor example, to define variables that you can access elsewhere in the find method, use the let option. To filter results using a\nvariable, you must access the variable within the $expr operator.\nCreate a collection cakeFlavors :\nThe following example defines a targetFlavor variable in let and\nuses the variable to retrieve the chocolate cake flavor:\nOutput:",
          "code_blocks": [
            "db. cakeFlavors . insertMany ( [ { _id : 1 , flavor : \"chocolate\" } , { _id : 2 , flavor : \"strawberry\" } , { _id : 3 , flavor : \"cherry\" } ] )",
            "db. cakeFlavors . find ( { $expr : { $eq : [ \"$flavor\" , \"$$targetFlavor\" ] } } , { _id : 0 } , { let : { targetFlavor : \"chocolate\" } } )",
            "[ { flavor : 'chocolate' } ]"
          ]
        },
        {
          "subsection_id": "retrieve-documents-for-roles-granted-to-the-current-user",
          "heading": "Retrieve Documents for Roles Granted to the Current User",
          "heading_level": 3,
          "content": "Starting in MongoDB 7.0, you can use the new USER_ROLES system variable to return user roles .\nThe scenario in this section shows users with various roles who have\nlimited access to documents in a collection containing budget\ninformation.\nThe scenario shows one possible use of USER_ROLES . The budget collection contains documents with a field named allowedRoles . As\nyou'll see in the following scenario, you can write queries that compare\nthe user roles found in the allowedRoles field with the roles\nreturned by the USER_ROLES system variable.",
          "code_blocks": []
        }
      ]
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "For another USER_ROLES example scenario, see Retrieve Medical Information for Roles Granted to the Current User . That\nexample doesn't store the user roles in the document fields, as is\ndone in the following example.\nFor the budget scenario in this section, perform the following steps to\ncreate the roles, users, and budget collection:\nRun:\nCreate users named John and Jane with the required roles.\nReplace the test database with your database name.\nRun:\nPerform the following steps to retrieve the documents accessible to John :\nRun:\nTo use a system variable, add $$ to the start of the variable name.\nSpecify the USER_ROLES system variable as $$USER_ROLES .\nRun:\nThe previous example returns the documents from the budget collection that match at least one of the roles that the user who runs\nthe example has. To do that, the example uses $setIntersection to return documents where the\nintersection between the budget document allowedRoles field and\nthe set of user roles from $$USER_ROLES is not empty.\nJohn has the Marketing , Operations , and Development roles, and sees these documents:\nPerform the following steps to retrieve the documents accessible to Jane :\nRun:\nJane has the Sales and Operations roles, and sees these\ndocuments:",
      "code_blocks": [
        "db. createRole ( { role : \"Marketing\" , roles : [ ] , privileges : [ ] } ) db. createRole ( { role : \"Sales\" , roles : [ ] , privileges : [ ] } ) db. createRole ( { role : \"Development\" , roles : [ ] , privileges : [ ] } ) db. createRole ( { role : \"Operations\" , roles : [ ] , privileges : [ ] } )",
        "db. createUser ( { user : \"John\" , pwd : \"jn008\" , roles : [ { role : \"Marketing\" , db : \"test\" } , { role : \"Development\" , db : \"test\" } , { role : \"Operations\" , db : \"test\" } , { role : \"read\" , db : \"test\" } ] } ) db. createUser ( { user : \"Jane\" , pwd : \"je009\" , roles : [ { role : \"Sales\" , db : \"test\" } , { role : \"Operations\" , db : \"test\" } , { role : \"read\" , db : \"test\" } ] } )",
        "db. budget . insertMany ( [ { _id : 0 , allowedRoles : [ \"Marketing\" ] , comment : \"For marketing team\" , yearlyBudget : 15000 } , { _id : 1 , allowedRoles : [ \"Sales\" ] , comment : \"For sales team\" , yearlyBudget : 17000 , salesEventsBudget : 1000 } , { _id : 2 , allowedRoles : [ \"Operations\" ] , comment : \"For operations team\" , yearlyBudget : 19000 , cloudBudget : 12000 } , { _id : 3 , allowedRoles : [ \"Development\" ] , comment : \"For development team\" , yearlyBudget : 27000 } ] )",
        "db. auth ( \"John\" , \"jn008\" )",
        "db. budget . find ( { $expr : { $not : { $eq : [ { $setIntersection : [ \"$allowedRoles\" , \"$$USER_ROLES.role\" ] } , [ ] ] } } } )",
        "[ { _id : 0 , allowedRoles : [ 'Marketing' ] , comment : 'For marketing team' , yearlyBudget : 15000 } , { _id : 2 , allowedRoles : [ 'Operations' ] , comment : 'For operations team' , yearlyBudget : 19000 , cloudBudget : 12000 } , { _id : 3 , allowedRoles : [ 'Development' ] , comment : 'For development team' , yearlyBudget : 27000 } ]",
        "db. auth ( \"Jane\" , \"je009\" )",
        "db. budget . find ( { $expr : { $not : { $eq : [ { $setIntersection : [ \"$allowedRoles\" , \"$$USER_ROLES.role\" ] } , [ ] ] } } } )",
        "[ { _id : 1 , allowedRoles : [ 'Sales' ] , comment : 'For sales team' , yearlyBudget : 17000 , salesEventsBudget : 1000 } , { _id : 2 , allowedRoles : [ 'Operations' ] , comment : 'For operations team' , yearlyBudget : 19000 , cloudBudget : 12000 } ]"
      ],
      "subsections": []
    },
    {
      "section_id": "note",
      "heading": "Note",
      "heading_level": 2,
      "content": "On a sharded cluster, a query can be run on a shard by another server\nnode on behalf of the user. In those queries, USER_ROLES is still\npopulated with the roles for the user.",
      "code_blocks": [],
      "subsections": [
        {
          "subsection_id": "modify-a-query-with-options",
          "heading": "Modify a Query with options",
          "heading_level": 3,
          "content": "The following examples show how you can use the options field\nin a find() query. Use the following insertMany() to setup the users collection:\nThe following query limits the number of documents in the result set\nwith the limit options parameter:\nThe following query uses the options parameter to enable allowDiskUse :\nThe following query uses the options parameter to get the executionStats explain output:\nThe following query uses multiple options in a single query. This\nquery uses limit set to 2 to return only two documents, and showRecordId set to true to return the position of the document\nin the result set:",
          "code_blocks": [
            "db. users . insertMany ( [ { username : \"david\" , age : 27 } , { username : \"amanda\" , age : 25 } , { username : \"rajiv\" , age : 32 } , { username : \"rajiv\" , age : 90 } ] )",
            "db. users . find ( { username : \"rajiv\" } , // query { age : 1 } , // projection { limit : 1 } // options )",
            "db. users . find ( { username : \"david\" } , { age : 1 } , { allowDiskUse : true } )",
            "var cursor = db. users . find ( { username : \"amanda\" } , { age : 1 } , { explain : \"executionStats\" } ) cursor. next ( )",
            "db. users . find ( { } , { username : 1 , age : 1 } , { limit : 2 , showRecordId : true } )"
          ]
        }
      ]
    },
    {
      "section_id": "learn-more",
      "heading": "Learn More",
      "heading_level": 2,
      "content": "- findOne()\n- findAndModify()\n- findOneAndDelete()\n- findOneAndReplace()\nfindOne()\nfindAndModify()\nfindOneAndDelete()\nfindOneAndReplace()\ndb.collection.explain\ndb.collection.findAndModify\n- Definition\n- Compatibility\n- Syntax\n- Behavior\n- Examples\n- Learn More\nBehavior\nLearn More\n- Definition\n- Compatibility\n- Syntax\n- Behavior\n- Examples\n- Learn More\nBehavior\nLearn More",
      "code_blocks": [],
      "subsections": []
    }
  ],
  "fetched_at": "2025-12-09T03:46:17.243987",
  "exam_code": "associate_developer_python",
  "domain_id": 2,
  "domain_name": "CRUD",
  "seed_id": "find",
  "source_type": "manual",
  "file_stub": "d2_find"
}